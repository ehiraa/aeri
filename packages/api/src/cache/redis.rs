use std::env;
use redis::{Client, ToRedisArgs, RedisResult, Commands};
use redis::streams::StreamReadReply;
use colourful_logger::Logger as Logger;
use lazy_static::lazy_static;

lazy_static! {
    static ref logger: Logger = Logger::default();
}

#[derive(Debug, Clone)]
pub struct Redis {
    client: Client,
}

impl Redis {
    pub fn new() -> Self {
        let redis_url = env::var("REDIS_URL").unwrap_or("redis://localhost:6379".to_string()).to_string();
        logger.debug_single(&format!("Created Client with URL : {}", redis_url), "Redis");
        Redis {
            client: Client::open(redis_url).unwrap(),
        }
    }

    pub fn get<T: ToRedisArgs + std::fmt::Debug>(&self, key: T) -> RedisResult<String> {
        logger.debug_single(&format!("Trying to grab key : {:?}", key), "Redis");
        let mut con = self.client.get_connection()?;
        let rv: Option<String> = con.get(key)?;

        match rv {
            Some(data) => {
                let data: serde_json::Value = serde_json::from_str(data.as_str()).unwrap();
                logger.debug_single("Found value for key", "Redis");

                let data = data.to_string();
                return Ok(data);
            },
            None => {
                logger.warn_single("No value found for key", "Redis");
                return Err(redis::RedisError::from((redis::ErrorKind::ResponseError, "No value found for key")));
            }
        }
    }

    pub fn set<T: ToRedisArgs + std::fmt::Debug, V: ToRedisArgs + std::fmt::Debug>(&self, key: T, value: V) -> RedisResult<()> {
        logger.debug_single(&format!("Setting Key with data {:?}", key).as_str(), "Redis");
        let mut con = self.client.get_connection()?;
        
        let result: RedisResult<()> = con.set(key, value);
        match result {
            Ok(_) => {
                return Ok(());
            },
            Err(e) => {
                logger.error_single(&format!("Error setting key : {:?}", e).as_str(), "Redis");
                return Err(e);
            }
        }
    }

    pub fn expire<T: ToRedisArgs + std::fmt::Debug>(&self, key: T, seconds: i64) -> RedisResult<()> {
        logger.debug_single(&format!("Setting Key to expire in {} seconds for key: {:?}", seconds, &key).as_str(), "Redis");
        let mut con: redis::Connection = self.client.get_connection()?;
        let result:  RedisResult<()> = con.expire(&key, seconds);
        
        match result {
            Ok(_) => {
                logger.debug_single(format!("{:?} has been set", key).as_str(), "Redis");
                return Ok(());
            },
            Err(e) => {
                logger.error_single(&format!("Error setting key to expire : {:?}", e).as_str(), "Redis");
                return Err(e);
            }
        }
    }

    pub fn ttl<T: ToRedisArgs + std::fmt::Debug>(&self, key: T) -> RedisResult<i64> {
        logger.debug_single(&format!("Getting TTL for key : {:?}", key).as_str(), "Redis");
        let mut con: redis::Connection = self.client.get_connection()?;
        let result:  RedisResult<i64> = con.ttl(key);

        match result {
            Ok(data) => {
                logger.debug_single(&format!("TTL for key is : {}", data).as_str(), "Redis");
                return Ok(data);
            },
            Err(e) => {
                logger.error_single(&format!("Error getting TTL for key : {:?}", e).as_str(), "Redis");
                return Err(e);
            }
        }
    }

    pub fn del<T: ToRedisArgs + std::fmt::Debug>(&self, key: T) -> RedisResult<()> {
        logger.debug_single(&format!("Deleting key : {:?}", key).as_str(), "Redis");
        let mut con = self.client.get_connection()?;
        let result: RedisResult<()> = con.del(key);

        match result {
            Ok(_) => {
                logger.debug_single("Key has been deleted", "Redis");
                return Ok(());
            },
            Err(e) => {
                logger.error_single(&format!("Error deleting key : {:?}", e).as_str(), "Redis");
                return Err(e);
            }
        }
    }

    pub async fn expire_user<T: ToRedisArgs + std::fmt::Debug + std::fmt::Display>(&self, k: T) -> RedisResult<()> {
        logger.debug_single(&format!("Deleting all cached related for user ID {:?}", k).as_str(), "Redis");
        let mut con = self.client.get_connection()?;
    
        let mut count = 0;
        let iter: redis::Iter<String> = con.scan()?;
        let keys: Vec<String> = iter.collect();
        for key in keys {
            let parts: Vec<&str> = key.split(":").collect();
            logger.debug_single(&format!("Split up parts: {:?}", &parts), "Redis");

            if parts.get(1) == Some(&k.to_string().as_str()) {
                logger.debug_single(&format!("Found Key: {:?}", key), "Redis");
                let _: () = con.del(key)?;
                count += 1;
            }
        }

        if count == 0 {
            logger.warn_single("No keys found", "Redis");
        }

        Ok(())
    }

    pub async fn setexp<T: ToRedisArgs + std::fmt::Debug, V: ToRedisArgs + std::fmt::Debug>(&self, key: T, value: V, seconds: u64) -> RedisResult<()> {
        logger.debug_single(&format!("Setting {:?} with data and expiring in {} seconds", key, seconds).as_str(), "Redis");
        let mut con = self.client.get_connection()?;
        
        let result: RedisResult<()> = con.set_ex(key, value, seconds);
        match result {
            Ok(_) => {
                return Ok(());
            },
            Err(e) => {
                logger.error_single(&format!("Error setting key : {:?}", e).as_str(), "Redis");
                return Err(e);
            }
        }
    }

    pub async fn hgetall<T: ToRedisArgs + std::fmt::Debug>(&self, key: T) -> RedisResult<std::collections::HashMap<String, String>> {
        logger.debug_single(&format!("Trying to grab key : {:?}", key), "Redis");
        let mut con = self.client.get_connection()?;
        let rv: std::collections::HashMap<String, String> = con.hgetall(key)?;

        if rv.is_empty() {
            logger.warn_single("No value found for key", "Redis");
            return Err(redis::RedisError::from((redis::ErrorKind::ResponseError, "No value found for key")));
        }

        logger.debug_single("Found value for key", "Redis");
        Ok(rv)
    }

    pub async fn hdel<T: ToRedisArgs + std::fmt::Debug>(&self, key: T, field: T) -> RedisResult<()> {
        logger.debug_single(&format!("Deleting field : {:?} from key : {:?}", field, key), "Redis");
        let mut con = self.client.get_connection()?;
        let result: RedisResult<()> = con.hdel(key, field);

        match result {
            Ok(_) => {
                logger.debug_single("Field has been deleted", "Redis");
                return Ok(());
            },
            Err(e) => {
                logger.error_single(&format!("Error deleting field : {:?}", e).as_str(), "Redis");
                return Err(e);
            }
        }
    }

    pub async fn hset<T: ToRedisArgs + std::fmt::Debug, V: ToRedisArgs + std::fmt::Debug>(&self, key: T, field: T, value: V) -> RedisResult<()> {
        let mut con = self.client.get_connection()?;
        
        let result: RedisResult<()> = con.hset(key, field, value);
        match result {
            Ok(_) => {
                return Ok(());
            },
            Err(e) => {
                logger.error_single(&format!("Error setting key : {:?}", e).as_str(), "Redis");
                return Err(e);
            }
        }
    }
    
    pub async fn xadd<T: ToRedisArgs + std::fmt::Debug, V: ToRedisArgs + std::fmt::Debug>(&self, stream: T, id: T, fields: Vec<(T, V)>) -> RedisResult<String> {
        logger.debug_single(&format!("Adding entry to stream {:?} with ID {:?}", stream, id).as_str(), "Redis");
        let mut con = self.client.get_connection()?;
        
        let result: RedisResult<String> = con.xadd(stream, id, &fields);
        match result {
            Ok(entry_id) => {
                logger.debug_single(&format!("Entry added with ID {:?}", entry_id).as_str(), "Redis");
                return Ok(entry_id);
            },
            Err(e) => {
                logger.error_single(&format!("Error adding entry to stream : {:?}", e).as_str(), "Redis");
                return Err(e);
            }
        }
    }

    pub async fn xread<T: ToRedisArgs + std::fmt::Debug>(&self, streams: Vec<T>, count: i64) -> RedisResult<Vec<StreamReadReply>> {
        logger.debug_single(&format!("Reading from streams : {:?}", streams).as_str(), "Redis");
        let mut con = self.client.get_connection()?;
        
        let result: RedisResult<Vec<StreamReadReply>> = con.xread(&streams, &[count]);
        match result {
            Ok(entries) => {
                logger.debug_single(&format!("Entries read : {:?}", entries).as_str(), "Redis");
                return Ok(entries);
            },
            Err(e) => {
                logger.error_single(&format!("Error reading from streams : {:?}", e).as_str(), "Redis");
                return Err(e);
            }
        }
    }

    pub async fn xrange<T: ToRedisArgs + std::fmt::Debug>(&self, stream: T, start: T, end: T) -> RedisResult<Vec<StreamReadReply>> {
        logger.debug_single(&format!("Reading from stream : {:?}", stream).as_str(), "Redis");
        let mut con = self.client.get_connection()?;
        
        let result: RedisResult<Vec<StreamReadReply>> = con.xrange(stream, start, end);
        match result {
            Ok(entries) => {
                logger.debug_single(&format!("Entries read : {:?}", entries).as_str(), "Redis");
                return Ok(entries);
            },
            Err(e) => {
                logger.error_single(&format!("Error reading from stream : {:?}", e).as_str(), "Redis");
                return Err(e);
            }
        }
    }

}